
## 在 https://olivegardenmenue.com/ 中读取出所有的结构化菜单数据
```js
// =================================================================================
//  更强大的标题查找函数
// =================================================================================
/**
 * 从一个起始元素开始，向上和向前遍历DOM，查找最接近的指定标签名的前置元素。
 * @param {Element} startElement - 开始查找的元素。
 * @param {string} tagName - 要查找的HTML标签名 (例如 'h2', 'h3')。
 * @returns {Element|null} - 找到的元素或 null。
 */
function findClosestPreviousElementByTag(startElement, tagName) {
    let current = startElement;
    tagName = tagName.toUpperCase();

    // 当我们还没有遍历到文档顶部时
    while (current && current.parentElement) {
        let sibling = current.previousElementSibling;

        // 遍历当前层级的所有前置兄弟节点
        while (sibling) {
            if (sibling.tagName === tagName) {
                return sibling; // 如果兄弟节点本身就是目标，直接返回
            }
            // 检查兄弟节点内部是否包含这个标签（查找最后一个，因为它离得最近）
            const potentialMatches = Array.from(sibling.querySelectorAll(tagName));
            if (potentialMatches.length > 0) {
                return potentialMatches[potentialMatches.length - 1];
            }
            sibling = sibling.previousElementSibling;
        }

        // 如果在当前层级没找到，就上升到父级，继续循环
        current = current.parentElement;
    }

    return null; // 遍历完也没找到
}


// =================================================================================
//  主逻辑
// =================================================================================

// 最终用于存储所有分类数据的对象
const categorizedData = {};

// 1. 找到所有包含 '$' 的 'mark' 标签
const allPriceMarks = Array.from(document.querySelectorAll('mark')).filter(mark => mark.textContent.includes('$'));

// 2. 遍历这些mark标签，为每个菜品提取数据并确定其分类
allPriceMarks.forEach(mark => {
    const parentCol = mark.closest('.kt-inside-inner-col');
    if (!parentCol) return;

    // --- 提取单个菜品信息 (这部分逻辑不变) ---
    const imageElement = parentCol.querySelector('img');
    const imageUrl = imageElement ? imageElement.src : '图片未找到';
    const price = mark.textContent.trim();
    const titleElement = parentCol.querySelector('p:not(:has(mark))');
    const title = titleElement ? titleElement.textContent.trim() : '标题未找到';

    let calories = '卡路里未找到';
    const priceParagraph = mark.closest('p');
    if (priceParagraph) {
        const fullText = priceParagraph.textContent;
        const priceText = mark.textContent;
        const remainingText = fullText.replace(priceText, '');
        const calMatch = remainingText.match(/[\d,+-]+/);
        if (calMatch && calMatch[0]) {
            calories = calMatch[0].replace(/,/g, '');
        }
    }

    const itemData = { title, imageUrl, price, calories };

    // --- 使用新的强大逻辑确定菜品分类 ---
    const menuBlock = mark.closest('.kb-row-layout-wrap');
    let categoryName = 'Uncategorized'; // 默认分类名

    if (menuBlock) {
        const h2Found = findClosestPreviousElementByTag(menuBlock, 'h2');
        const h3Found = findClosestPreviousElementByTag(menuBlock, 'h3');

        const h2Text = h2Found ? h2Found.textContent.trim() : null;
        let h3Text = h3Found ? h3Found.textContent.trim() : null;

        // 关键验证：必须确保找到的 h3 是在 h2 之后，才算是 h2 的子分类
        // Node.DOCUMENT_POSITION_FOLLOWING 表示 h2 在 h3 之前
        if (h2Found && h3Found && !(h2Found.compareDocumentPosition(h3Found) & Node.DOCUMENT_POSITION_FOLLOWING)) {
            h3Text = null; // 如果 h3 在 h2 前面，那么这个 h3 不属于这个 h2，忽略它
        }

        if (h2Text) {
            categoryName = h3Text ? `${h2Text} - ${h3Text}` : h2Text;
        }
    }

    // --- 将菜品信息添加到最终数据对象中 ---
    if (!categorizedData[categoryName]) {
        categorizedData[categoryName] = { items: [] };
    }
    categorizedData[categoryName].items.push(itemData);
});


// 3. 下载JSON函数 (无需修改)
function downloadJSON(data, filename = 'menu-data.json') {
    const jsonStr = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// 4. 执行并输出结果
if (Object.keys(categorizedData).length > 0) {
    console.log('成功提取并分类以下数据:', categorizedData);
    downloadJSON(categorizedData);
    console.log('已按分类结构生成JSON文件并开始下载。');
} else {
    console.log("页面上没有找到任何包含 '$' 的 <mark> 标签，或者无法提取相应数据。");
}
```


## 夏威夷的菜单数据获取
- MenuCard.js 在订购页 搜索 MenuCard.js 关键词 进行debug 追踪到上一层的调用的props
- 但是这个里面没有卡路里的信息 所以需要自己结合首页
- Catering Family Bundles 和 Catering Family Size Pans (Serves 4-6) 这两个是只能外卖才有的